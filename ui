--[[
    Enhanced UI Library for Roblox
    Refactored for clarity, maintainability, and Luau type safety.
]]

-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService") -- Added for potential future use (e.g., custom animations, updates)

-- Types (Luau)
type GuiObject = Instance
type UDim2Value = UDim2
type Color3Value = Color3
type Vector2Value = Vector2
type FontEnum = Enum.Font
type EasingStyleEnum = Enum.EasingStyle
type EasingDirectionEnum = Enum.EasingDirection
type UserInputTypeEnum = Enum.UserInputType
type KeyCodeEnum = Enum.KeyCode

type CallbackFunction = (...any) -> ...any
type GetListFunction = () -> {string}

type BaseUINodeType = {
    Type: number,
    Parent: BaseUINodeType?,
    Children: {BaseUINodeType},
    GuiObject: GuiObject?,
    AddChild: (self: BaseUINodeType, childNode: BaseUINodeType) -> (),
    RecursiveUpdateGui: (self: BaseUINodeType) -> (),
    UpdateGui: (self: BaseUINodeType) -> (),
    __index: any -- for metatable
}

type BaseUIElementType = BaseUINodeType & {
    Value: any?,
    Title: string?,
    Size: UDim2Value,
    Position: UDim2Value,
    SetValue: (self: BaseUIElementType, ...any) -> (),
    GetValue: (self: BaseUIElementType) -> any?,
}

type CollapsibleContainerType = BaseUINodeType & {
    Title: string,
    Collapsed: boolean,
    Height: number,
    Header: any, -- HeaderLabelType, but forward declaration is tricky in pure Lua for types
    ReorderGui: (self: CollapsibleContainerType, instant: boolean?) -> (),
    Collapse: (self: CollapsibleContainerType) -> (),
    Expand: (self: CollapsibleContainerType) -> (),
    AddEntry: (self: CollapsibleContainerType, entry: BaseEntryType) -> (),
    CreateSection: (self: CollapsibleContainerType, title: string) -> SectionType,
    CreateButton: (self: CollapsibleContainerType, title: string, callback: CallbackFunction) -> BaseEntryType,
    CreateSlider: (self: CollapsibleContainerType, title: string, callback: (newValue: number) -> (), min: number, max: number, step: number?, dynamic: boolean?, defaultValue: number?) -> SliderEntryType,
    CreateTextBox: (self: CollapsibleContainerType, title: string, callback: (newText: string) -> (), acceptFormat: string?, dynamic: boolean?, defaultValue: string?) -> TextBoxEntryType,
    CreateColorPicker: (self: CollapsibleContainerType, title: string, callback: (newColor: Color3Value) -> (), dynamic: boolean?, defaultColor: Color3Value?) -> ColorPickerEntryType,
    CreateSelector: (self: CollapsibleContainerType, title: string, callback: (selectedValue: string) -> (), getListFunc: GetListFunction, defaultValue: string?) -> SelectorEntryType,
    CreateSwitch: (self: CollapsibleContainerType, title: string, callback: (isOn: boolean) -> (), defaultValue: boolean?) -> SwitchEntryType,
    CreateTextLabel: (self: CollapsibleContainerType, text: string) -> BaseEntryType,
    CreateKeyDetector: (self: CollapsibleContainerType, title: string, callback: (newKey: KeyCodeEnum) -> (), defaultValue: KeyCodeEnum?) -> KeyInputEntryType
}
-- Forward declare other types as needed if strict typing is desired for all cross-references
type BaseEntryType = BaseUINodeType & { Value: any?, Height: number }
type SliderEntryType = BaseEntryType & { Slider: any } -- SliderType
type TextBoxEntryType = BaseEntryType & { TextBox: any } -- TextBoxType
type ColorPickerEntryType = BaseEntryType & { ColorPicker: any } -- ColorPickerType
type SelectorEntryType = BaseEntryType & { Selector: any, Button: TextButton, Indicator: TextLabel, Toggled: boolean, Toggle: (self: SelectorEntryType) -> () } -- SelectorListType
type SwitchEntryType = BaseEntryType & { Switch: any } -- SwitchType
type KeyInputEntryType = BaseEntryType & { KeyDetector: any } -- KeyInputType
type SectionType = CollapsibleContainerType
type CategoryType = CollapsibleContainerType & { Draggable: boolean, Position: UDim2Value, LastMousePosition: Vector2Value, DragActive: boolean, ApplyDraggability: (self: CategoryType) -> (), MoveTo: (self: CategoryType, position: UDim2Value) -> (), AutoMove: (self: CategoryType) -> () }
type RootUIType = BaseUINodeType & { ScreenGui: ScreenGui, Hide: (self: RootUIType) -> (), Show: (self: RootUIType) -> (), CleanUp: (self: RootUIType) -> (), CreateCategory: (self: RootUIType, title: string, positionOrDraggable: UDim2Value | boolean?) -> CategoryType, LoadConfig: (self: RootUIType, config: table) -> (), Init: (config: table?, parentGuiInstance: GuiObject?) -> RootUIType }


-- Enum for UI Element Types
local ElementType = {
    Unknown = 0,
    Root = 1,
    Category = 2,
    Section = 3,
    Header = 4,
    Entry = 5,
    UiElement = 6,
}

-- Base class for all UI nodes in the hierarchy
local BaseUINode: BaseUINodeType = {}
BaseUINode.__index = BaseUINode

function BaseUINode:New(elementType: number?, parentNode: BaseUINodeType?, guiObject: GuiObject?) : BaseUINodeType
    local newNode: BaseUINodeType = setmetatable({}, BaseUINode)
    newNode.Type = elementType or ElementType.Unknown
    newNode.Parent = parentNode -- Assuming self assignment or nil is intended
    newNode.Children = {}
    newNode.GuiObject = guiObject or nil

    if parentNode then
        parentNode:AddChild(newNode)
    end
    return newNode
end

function BaseUINode:AddChild(childNode: BaseUINodeType)
    childNode.Parent = self
    table.insert(self.Children, childNode)
    if childNode.GuiObject and self.GuiObject then
        childNode.GuiObject.Parent = self.GuiObject
    end
end

function BaseUINode:RecursiveUpdateGui()
    self:UpdateGui()
    for _, childNode: BaseUINodeType in ipairs(self.Children) do
        childNode:RecursiveUpdateGui()
    end
end

-- Default UpdateGui, to be overridden by derived classes
function BaseUINode:UpdateGui()
    -- Base implementation does nothing
end

-- Base class for interactable UI elements
local BaseUIElement: BaseUIElementType = setmetatable({}, BaseUINode)
BaseUIElement.__index = BaseUIElement

function BaseUIElement:New(size: UDim2Value, position: UDim2Value, title: string?) : BaseUIElementType
    local newElement = setmetatable(BaseUINode:New(ElementType.UiElement), BaseUIElement)
    newElement.Value = nil
    newElement.Title = title
    newElement.Size = size
    newElement.Position = position
    return newElement
end

function BaseUIElement:SetValue(...)
    -- To be implemented by derived classes
end

function BaseUIElement:GetValue()
    return self.Value
end

-- Theme / Configuration Settings
local Theme = {
    PrimaryColor = Color3.fromRGB(27, 38, 59),
    SecondaryColor = Color3.fromRGB(13, 27, 42),
    AccentColor = Color3.fromRGB(41, 115, 115),
    TextColor = Color3.new(1, 1, 1),
    Font = Enum.Font.Gotham,
    TextSize = 13,
    HeaderWidth = 300,
    HeaderHeight = 32,
    EntryMargin = 1,
    AnimationDuration = 0.4,
    AnimationEasingStyle = Enum.EasingStyle.Quint,
    DefaultEntryHeight = 35,
}

-- Collapse Button for Headers
local CollapseButton = setmetatable({}, BaseUIElement)
CollapseButton.__index = CollapseButton

function CollapseButton:New() : BaseUIElementType -- Actually returns a specialized BaseUIElement
    local newButton = setmetatable(BaseUIElement:New(
        UDim2.new(0, 20, 0, 20),
        UDim2.new(1, -20 - 5, 0.5, -20 / 2),
        ""
    ), CollapseButton)

    newButton.GuiObject = Instance.new("TextButton")
    local guiButton = newButton.GuiObject :: TextButton

    guiButton.MouseButton1Click:Connect(function()
        -- Parent structure: CollapseButton -> HeaderLabel -> CollapsibleContainer
        local headerLabel = newButton.Parent
        if headerLabel and headerLabel.Parent then
            local container = headerLabel.Parent :: CollapsibleContainerType
            container.Collapsed = not container.Collapsed
            if container.Collapsed then
                container:Collapse()
            else
                container:Expand()
            end
        end
    end)
    return newButton
end

function CollapseButton:TriggerCollapseVisual() -- Renamed from Collapse
    (self.GuiObject :: TextButton).Text = "+"
end

function CollapseButton:TriggerExpandVisual() -- Renamed from Expand
    (self.GuiObject :: TextButton).Text = "-"
end

function CollapseButton:UpdateGui()
    local guiButton = self.GuiObject :: TextButton
    guiButton.TextScaled = true
    guiButton.TextColor3 = Theme.TextColor
    guiButton.BackgroundTransparency = 1
    guiButton.Size = self.Size
    guiButton.Position = self.Position

    local headerLabel = self.Parent
    if headerLabel and headerLabel.Parent then
        local container = headerLabel.Parent :: CollapsibleContainerType
        if container.Collapsed then
            guiButton.Text = "+"
        else
            guiButton.Text = "-"
        end
    end
end

-- Header Label for Sections and Categories
local HeaderLabel = setmetatable({}, BaseUINode)
HeaderLabel.__index = HeaderLabel

function HeaderLabel:New() : BaseUINodeType -- Actually HeaderLabelType
    local newHeader = setmetatable(BaseUINode:New(ElementType.Header), HeaderLabel)
    newHeader.GuiObject = Instance.new("TextLabel")

    local collapseBtn = CollapseButton:New()
    newHeader:AddChild(collapseBtn)
    (newHeader :: any).CollapseButton = collapseBtn -- Store reference

    return newHeader
end

function HeaderLabel:UpdateGui()
    local guiLabel = self.GuiObject :: TextLabel
    local parentContainer = self.Parent :: CollapsibleContainerType

    guiLabel.Size = UDim2.new(1, 0, 0, Theme.HeaderHeight)
    guiLabel.Text = parentContainer.Title
    guiLabel.TextSize = Theme.TextSize * 1.25
    guiLabel.TextColor3 = Theme.TextColor
    guiLabel.Font = Theme.Font
    guiLabel.BorderSizePixel = 0
    guiLabel.BackgroundColor3 = Theme.SecondaryColor

    if parentContainer.Type == ElementType.Category then
        guiLabel.TextSize = Theme.TextSize * 1.5 -- Slightly larger for Categories
    end
end

-- Base class for Entries (wrappers for UI elements within containers)
local BaseEntry: BaseEntryType = setmetatable({}, BaseUINode)
BaseEntry.__index = BaseEntry

function BaseEntry:New(height: number?) : BaseEntryType
    local newEntry = setmetatable(BaseUINode:New(ElementType.Entry), BaseEntry)
    newEntry.Value = nil -- Can be used by specific entry types
    newEntry.Height = height or Theme.DefaultEntryHeight
    newEntry.GuiObject = Instance.new("Frame")
    return newEntry
end

function BaseEntry:SetValue(...)
    -- To be implemented by derived classes if needed
end

function BaseEntry:GetValue()
    -- To be implemented by derived classes if needed
    return self.Value
end

function BaseEntry:UpdateGui()
    local guiFrame = self.GuiObject :: Frame
    guiFrame.BackgroundColor3 = Theme.PrimaryColor
    guiFrame.BorderSizePixel = 0
    guiFrame.Size = UDim2.new(1, 0, 0, self.Height)
end


-- Collapsible Container (base for Sections and Categories)
local CollapsibleContainer: CollapsibleContainerType = setmetatable({}, BaseUINode)
CollapsibleContainer.__index = CollapsibleContainer

function CollapsibleContainer:New(title: string?, type: number) : CollapsibleContainerType
    local newContainer = setmetatable(BaseUINode:New(type), CollapsibleContainer)
    newContainer.Title = title or ""
    newContainer.Collapsed = false
    newContainer.Height = 0 -- Calculated dynamically
    newContainer.GuiObject = Instance.new("Frame")

    newContainer.Header = HeaderLabel:New() -- Create and add header
    newContainer:AddChild(newContainer.Header)

    return newContainer
end

function CollapsibleContainer:UpdateGui()
    local guiFrame = self.GuiObject :: Frame
    guiFrame.Size = UDim2.new(0, Theme.HeaderWidth, 0, 0) -- Initial size, ReorderGui will adjust height
    guiFrame.BackgroundColor3 = Theme.SecondaryColor
    guiFrame.BorderSizePixel = 0
    guiFrame.ClipsDescendants = true
    self:ReorderGui(true) -- Initial ordering, no animation
end

function CollapsibleContainer:ReorderGui(instant: boolean?)
    instant = instant or false
    local animationDuration = if instant then 0 else Theme.AnimationDuration

    self.Height = Theme.HeaderHeight -- Start with header height

    if not self.Collapsed then
        for _, childNode: BaseUINodeType in ipairs(self.Children) do
            if childNode.Type ~= ElementType.Header then -- Only process entries, not the header itself
                local entryNode = childNode :: BaseEntryType
                if entryNode.GuiObject then
                    (entryNode.GuiObject :: GuiObject):TweenPosition(
                        UDim2.new(0, 0, 0, self.Height),
                        Enum.EasingDirection.InOut,
                        Theme.AnimationEasingStyle,
                        animationDuration,
                        true
                    )
                    self.Height = self.Height + entryNode.Height + Theme.EntryMargin
                end
            end
        end
        if #self.Children > 1 then -- if there are any entries besides the header
            self.Height = self.Height - Theme.EntryMargin -- Remove last margin
        end
    end

    (self.GuiObject :: Frame):TweenSize(
        UDim2.new(0, Theme.HeaderWidth, 0, self.Height),
        Enum.EasingDirection.InOut,
        Theme.AnimationEasingStyle,
        animationDuration,
        true
    )

    -- If this container is part of another container, reorder the parent as well
    if self.Parent and self.Parent.Type ~= ElementType.Root then
        (self.Parent :: CollapsibleContainerType):ReorderGui(instant)
    end
end

function CollapsibleContainer:Collapse()
    self.Collapsed = true
    local header = self.Header :: { CollapseButton: { TriggerCollapseVisual: () -> ()}}
    if header and header.CollapseButton then
        header.CollapseButton:TriggerCollapseVisual()
    end
    self:ReorderGui()
end

function CollapsibleContainer:Expand()
    self.Collapsed = false
    local header = self.Header :: { CollapseButton: { TriggerExpandVisual: () -> ()}}
    if header and header.CollapseButton then
        header.CollapseButton:TriggerExpandVisual()
    end
    self:ReorderGui()
end

function CollapsibleContainer:AddEntry(entry: BaseEntryType)
    self:AddChild(entry)
    entry:RecursiveUpdateGui() -- Update the new entry's GUI
    self:ReorderGui(true) -- Reorder instantly
end

-- Section (a type of CollapsibleContainer)
local Section: SectionType = setmetatable({}, CollapsibleContainer)
Section.__index = Section

function Section:New(title: string?) : SectionType
    local newSection = setmetatable(CollapsibleContainer:New(title, ElementType.Section), Section)
    return newSection
end

function CollapsibleContainer:CreateSection(title: string) : SectionType
    local newSection = Section:New(title)
    self:AddChild(newSection) -- Assuming a Section can be a child of another CollapsibleContainer (e.g. Category)
    newSection:RecursiveUpdateGui()
    if self.Type == ElementType.Category then -- If adding to a Category, reorder the category
         self:ReorderGui(true)
    end
    return newSection
end


-- Category (a draggable CollapsibleContainer)
local Category: CategoryType = setmetatable({}, CollapsibleContainer)
Category.__index = Category

function Category:New(title: string?, draggable: boolean?) : CategoryType
    local newCategory = setmetatable(CollapsibleContainer:New(title, ElementType.Category), Category)
    newCategory.Draggable = draggable or true
    newCategory.Position = UDim2.new(0, 0, 0, 0) -- Default position
    newCategory.DragActive = false
    newCategory.LastMousePosition = Vector2.new(0,0)

    if newCategory.Draggable then
        newCategory:ApplyDraggability()
    end
    return newCategory
end

function Category:MoveTo(position: UDim2Value)
    self.Position = position
    if self.GuiObject then
        (self.GuiObject :: Frame).Position = position
    end
end

function Category:AutoMove()
    -- Automatically position based on other categories in the root
    local numCategories = 0
    if self.Parent and self.Parent.Children then
        for _, child in ipairs(self.Parent.Children) do
            if child.Type == ElementType.Category then
                numCategories += 1
            end
        end
    end
    self:MoveTo(UDim2.fromOffset(100 + (numCategories -1) * (Theme.HeaderWidth * 1.25), 36))
end

function Category:ApplyDraggability()
    if not self.Header or not self.Header.GuiObject then return end

    local headerGui = self.Header.GuiObject :: TextLabel
    self.LastMousePosition = UserInputService:GetMouseLocation() -- Initialize

    headerGui.InputBegan:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and self.Draggable then
            self.DragActive = true
            self.LastMousePosition = UserInputService:GetMouseLocation() -- Update on drag start
        end
    end)

    headerGui.InputEnded:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
            self.DragActive = false
        end
    end)

    UserInputService.InputChanged:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
            if self.DragActive and self.GuiObject then
                local currentMousePosition = UserInputService:GetMouseLocation()
                local delta = currentMousePosition - self.LastMousePosition
                local currentGuiPosition = (self.GuiObject :: Frame).Position
                self:MoveTo(UDim2.new(
                    currentGuiPosition.X.Scale, currentGuiPosition.X.Offset + delta.X,
                    currentGuiPosition.Y.Scale, currentGuiPosition.Y.Offset + delta.Y
                ))
            end
            self.LastMousePosition = UserInputService:GetMouseLocation() -- Always update last position
        end
    end)
end

-- Button Element
local ButtonElement = setmetatable({}, BaseUIElement)
ButtonElement.__index = ButtonElement

function ButtonElement:New(size: UDim2Value, position: UDim2Value, title: string, callback: CallbackFunction) : BaseUIElementType
    local newButton = setmetatable(BaseUIElement:New(size, position, title), ButtonElement)
    newButton.GuiObject = Instance.new("TextButton")
    local guiButton = newButton.GuiObject :: TextButton
    guiButton.MouseButton1Click:Connect(function()
        pcall(callback) -- Wrap callback in pcall for safety
    end)
    return newButton
end

function ButtonElement:UpdateGui()
    local guiButton = self.GuiObject :: TextButton
    guiButton.BorderSizePixel = 0
    guiButton.BackgroundColor3 = Theme.SecondaryColor
    guiButton.TextColor3 = Theme.TextColor
    guiButton.Size = self.Size
    guiButton.Position = self.Position
    guiButton.Text = self.Title
    guiButton.TextSize = Theme.TextSize
    guiButton.Font = Theme.Font
end

function CollapsibleContainer:CreateButton(title: string, callback: CallbackFunction) : BaseEntryType
    local entryWrapper = BaseEntry:New() -- Uses default height
    local button = ButtonElement:New(
        UDim2.new(1, -10, 1, -10), -- Size relative to entry, with margin
        UDim2.new(0, 5, 0, 5),   -- Position relative to entry, with margin
        title,
        callback
    )
    entryWrapper:AddChild(button)
    self:AddEntry(entryWrapper)
    return entryWrapper
end


-- Slider Element
local SliderElement = setmetatable({}, BaseUIElement)
SliderElement.__index = SliderElement

function SliderElement:New(
    size: UDim2Value, position: UDim2Value, title: string,
    callback: (newValue: number) -> (),
    minVal: number, maxVal: number, stepVal: number?,
    isDynamic: boolean?, initialValue: number?, customColor: Color3Value?
) : BaseUIElementType -- Returns a specialized SliderElement
    local newSlider = setmetatable(BaseUIElement:New(size, position, title), SliderElement)
    newSlider.Callback = callback
    newSlider.Dynamic = isDynamic or false
    newSlider.Step = stepVal or 0.01
    newSlider.Max = maxVal
    newSlider.Min = minVal
    newSlider.CustomColor = customColor
    newSlider.Value = initialValue or newSlider.Min -- Initial value or min

    newSlider.GuiObject = Instance.new("Frame")
    local mainFrame = newSlider.GuiObject :: Frame

    local background = Instance.new("Frame", mainFrame)
    local textBox = Instance.new("TextBox", mainFrame)
    local overlay = Instance.new("Frame", background)
    local handle = Instance.new("Frame", overlay) -- Handle on the overlay for visual cue
    local label = Instance.new("TextLabel", background) -- Label inside the background, not mainFrame

    ;(newSlider :: any).BackgroundFrame = background
    ;(newSlider :: any).InputBox = textBox
    ;(newSlider :: any).OverlayFrame = overlay
    ;(newSlider :: any).HandleFrame = handle
    ;(newSlider :: any).TitleLabel = label
    ;(newSlider :: any).IsActive = false -- For dragging

    background.InputBegan:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
            (newSlider :: any).IsActive = true
            local relativeX = math.clamp(inputObject.Position.X - background.AbsolutePosition.X, 0, background.AbsoluteSize.X)
            local ratio = relativeX / background.AbsoluteSize.X
            newSlider:SetValue(newSlider.Min + (ratio * (newSlider.Max - newSlider.Min)))
            -- Callback is called on InputEnded unless dynamic
        end
    end)

    background.InputEnded:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
            (newSlider :: any).IsActive = false
            pcall(newSlider.Callback, newSlider.Value) -- Call on release
        end
    end)

    UserInputService.InputChanged:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
            if (newSlider :: any).IsActive then
                local relativeX = math.clamp(inputObject.Position.X - background.AbsolutePosition.X, 0, background.AbsoluteSize.X)
                local ratio = relativeX / background.AbsoluteSize.X
                newSlider:SetValue(newSlider.Min + (ratio * (newSlider.Max - newSlider.Min)))
                if newSlider.Dynamic then
                    pcall(newSlider.Callback, newSlider.Value)
                end
            end
        end
    end)

    textBox.FocusLost:Connect(function(enterPressed: boolean)
        local numValue = tonumber(textBox.Text)
        if numValue then
            newSlider:SetValue(numValue)
            pcall(newSlider.Callback, newSlider.Value)
        else
            textBox.Text = tostring(newSlider.Value) -- Revert to current value if input is invalid
        end
    end)

    return newSlider
end

function SliderElement:SetValue(newValue: number)
    local rawValue = newValue
    local steppedValue = rawValue - (rawValue % self.Step)
    self.Value = math.clamp(steppedValue, self.Min, self.Max)

    local overlayFrame = (self :: any).OverlayFrame :: Frame
    local inputBox = (self :: any).InputBox :: TextBox

    if self.Max == self.Min then -- Avoid division by zero
        overlayFrame.Size = UDim2.new(0,0,1,0)
    else
        overlayFrame.Size = UDim2.new((self.Value - self.Min) / (self.Max - self.Min), 0, 1, 0)
    end
    inputBox.Text = tostring(self.Value)
end

function SliderElement:UpdateGui()
    local mainFrame = self.GuiObject :: Frame
    local backgroundFrame = (self :: any).BackgroundFrame :: Frame
    local inputBox = (self :: any).InputBox :: TextBox
    local overlayFrame = (self :: any).OverlayFrame :: Frame
    local handleFrame = (self :: any).HandleFrame :: Frame
    local titleLabel = (self :: any).TitleLabel :: TextLabel

    mainFrame.BackgroundColor3 = Theme.SecondaryColor -- Or Primary, depending on desired look
    mainFrame.Size = self.Size
    mainFrame.Position = self.Position
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundTransparency = 1 -- Make main frame transparent, bg takes color

    backgroundFrame.BorderSizePixel = 0
    backgroundFrame.Size = UDim2.new(1 - 0.2, 0, 1, 0) -- 80% width for slider bar
    backgroundFrame.Position = UDim2.new(0,0,0,0) -- Align left
    backgroundFrame.BackgroundColor3 = Theme.SecondaryColor

    inputBox.Size = UDim2.new(0.2, -5, 1, 0) -- 20% width for text box, with margin
    inputBox.Position = UDim2.new(0.8, 5, 0, 0) -- Align right
    inputBox.BorderSizePixel = 0
    inputBox.BackgroundColor3 = Theme.SecondaryColor
    inputBox.TextColor3 = Theme.TextColor
    inputBox.TextWrapped = true -- Should be false for numbers usually
    inputBox.Font = Theme.Font
    inputBox.TextSize = Theme.TextSize

    overlayFrame.BorderSizePixel = 0
    overlayFrame.BackgroundColor3 = self.CustomColor or Theme.AccentColor

    handleFrame.Size = UDim2.new(0, 5, 1, 0) -- Visual handle at the end of the overlay
    handleFrame.Position = UDim2.new(1, -(5 / 2), 0, 0) -- Centered at the end of overlay
    handleFrame.BackgroundColor3 = Color3.new(1, 1, 1)
    handleFrame.BorderSizePixel = 0

    titleLabel.Text = self.Title
    titleLabel.Font = Theme.Font
    titleLabel.TextSize = Theme.TextSize
    titleLabel.BackgroundTransparency = 1
    titleLabel.Size = UDim2.new(1, 0, 1, 0) -- Full size of background
    titleLabel.Position = UDim2.new(0,0,0,0)
    titleLabel.TextColor3 = Theme.TextColor
    titleLabel.ZIndex = 2 -- Ensure label is above overlay

    self:SetValue(self.Value) -- Apply current value to UI
end

-- Slider Entry (wraps SliderElement in an Entry)
local SliderEntry: SliderEntryType = setmetatable({}, BaseEntry)
SliderEntry.__index = SliderEntry

function SliderEntry:New(
    title: string, callback: (newValue: number) -> (),
    minVal: number, maxVal: number, stepVal: number?,
    isDynamic: boolean?, initialValue: number?
) : SliderEntryType
    local newSliderEntry = setmetatable(BaseEntry:New(), SliderEntry) -- Default entry height
    newSliderEntry.Slider = SliderElement:New(
        UDim2.new(1, -10, 1, -14),  -- Size within entry
        UDim2.new(0, 5, 0, 7),    -- Position within entry
        title, callback, minVal, maxVal, stepVal, isDynamic, initialValue
    )
    newSliderEntry:SetValue(initialValue or newSliderEntry:GetValue()) -- Set initial value correctly
    newSliderEntry:AddChild(newSliderEntry.Slider)
    return newSliderEntry
end

function SliderEntry:SetValue(newValue: number)
    self.Value = newValue -- Store value on entry as well potentially
    self.Slider:SetValue(newValue)
end

function SliderEntry:GetValue() : number
    return self.Slider:GetValue()
end

function CollapsibleContainer:CreateSlider(
    title: string, callback: (newValue: number) -> (),
    minVal: number, maxVal: number, stepVal: number?,
    isDynamic: boolean?, initialValue: number?
) : SliderEntryType
    local newSliderEntry = SliderEntry:New(title, callback, minVal, maxVal, stepVal, isDynamic, initialValue)
    self:AddEntry(newSliderEntry)
    return newSliderEntry
end

-- TextBox Element
local TextBoxElement = setmetatable({}, BaseUIElement)
TextBoxElement.__index = TextBoxElement

function TextBoxElement:New(
    size: UDim2Value, position: UDim2Value, placeholder: string,
    callback: (newText: string) -> (),
    acceptFormat: string?, isDynamic: boolean?, initialValue: string?
) : BaseUIElementType -- Returns specialized TextBoxElement
    local newTextBox = setmetatable(BaseUIElement:New(size, position, placeholder), TextBoxElement) -- Title used as placeholder
    newTextBox.Callback = callback
    newTextBox.Dynamic = isDynamic or false
    newTextBox.Value = initialValue or ""
    newTextBox.AcceptFormat = acceptFormat or "^.*$" -- Default: accept any string

    newTextBox.GuiObject = Instance.new("TextBox")
    local guiTextBox = newTextBox.GuiObject :: TextBox

    guiTextBox.FocusLost:Connect(function(enterPressed: boolean)
        if string.match(guiTextBox.Text, newTextBox.AcceptFormat :: string) then
            newTextBox:SetValue(guiTextBox.Text) -- This updates newTextBox.Value
            pcall(newTextBox.Callback, newTextBox.Value)
        else
            guiTextBox.Text = newTextBox.Value :: string -- Revert if format mismatch
        end
    end)

    guiTextBox.Changed:Connect(function(property: string)
        if newTextBox.Dynamic and property == "Text" and guiTextBox:IsFocused() then
            if string.match(guiTextBox.Text, newTextBox.AcceptFormat :: string) then
                 newTextBox:SetValue(guiTextBox.Text)
                 pcall(newTextBox.Callback, newTextBox.Value)
            -- else: Potentially revert here too or provide visual feedback for invalid dynamic input
            end
        end
    end)
    return newTextBox
end

function TextBoxElement:SetValue(newText: string)
    self.Value = newText
    if self.GuiObject then
        (self.GuiObject :: TextBox).Text = newText
    end
end

function TextBoxElement:UpdateGui()
    local guiTextBox = self.GuiObject :: TextBox
    guiTextBox.BackgroundColor3 = Theme.SecondaryColor
    guiTextBox.TextColor3 = Theme.TextColor
    guiTextBox.PlaceholderText = self.Title -- Title used as placeholder
    guiTextBox.PlaceholderColor3 = Theme.TextColor:Lerp(Theme.SecondaryColor, 0.5) -- Dimmed placeholder
    guiTextBox.Position = self.Position
    guiTextBox.Size = self.Size
    guiTextBox.TextSize = Theme.TextSize
    guiTextBox.Font = Theme.Font
    guiTextBox.BorderSizePixel = 0
    guiTextBox.ClearTextOnFocus = false -- Personal preference, usually false
    self:SetValue(self.Value :: string)
end

-- TextBox Entry
local TextBoxEntry: TextBoxEntryType = setmetatable({}, BaseEntry)
TextBoxEntry.__index = TextBoxEntry

function TextBoxEntry:New(
    placeholder: string, callback: (newText: string) -> (),
    acceptFormat: string?, isDynamic: boolean?, initialValue: string?
) : TextBoxEntryType
    local newEntry = setmetatable(BaseEntry:New(), TextBoxEntry)
    newEntry.TextBox = TextBoxElement:New(
        UDim2.new(1, -10, 1, -10), UDim2.new(0, 5, 0, 5),
        placeholder, callback, acceptFormat, isDynamic, initialValue
    )
    newEntry:AddChild(newEntry.TextBox)
    -- Initial value is set by TextBoxElement's UpdateGui via SetValue
    return newEntry
end

function TextBoxEntry:SetValue(newText: string)
    self.Value = newText
    self.TextBox:SetValue(newText)
end

function TextBoxEntry:GetValue() : string
    return self.TextBox:GetValue()
end

function CollapsibleContainer:CreateTextBox(
    placeholder: string, callback: (newText: string) -> (),
    acceptFormat: string?, isDynamic: boolean?, initialValue: string?
) : TextBoxEntryType
    local newEntry = TextBoxEntry:New(placeholder, callback, acceptFormat, isDynamic, initialValue)
    self:AddEntry(newEntry)
    return newEntry
end

-- ColorPicker Element
local ColorPickerElement = setmetatable({}, BaseUIElement)
ColorPickerElement.__index = ColorPickerElement

function ColorPickerElement:New(
    size: UDim2Value, position: UDim2Value, title: string, -- Title not directly used in picker UI, but for context
    callback: (newColor: Color3Value) -> (),
    _dynamic: boolean?, -- Placeholder, dynamic behavior handled by parent entry
    initialColor: Color3Value?
) : BaseUIElementType -- Returns specialized ColorPickerElement
    local newPicker:any = setmetatable(BaseUIElement:New(size, position, title), ColorPickerElement)
    newPicker.Callback = callback
    newPicker.Value = initialColor or Theme.AccentColor -- Default color

    newPicker.GuiObject = Instance.new("Frame")
    local mainFrame = newPicker.GuiObject :: Frame

    -- Saturation/Value ImageLabel
    newPicker.SVImage = Instance.new("ImageLabel", mainFrame)
    newPicker.SVCursor = Instance.new("Frame", newPicker.SVImage) -- Cursor for SV selection

    -- Sliders: R, G, B, Hue (or Value), Alpha (optional)
    -- Using existing SliderElement for RGB and Value (Brightness)
    local sliderWidthScale = 0.5
    local sliderMargin = 5
    local sliderHeight = 1/6 -- As fraction of total height, or fixed pixel
    local sliderYOffsetStep = 1/6

    newPicker.RSlider = SliderElement:New(
        UDim2.new(sliderWidthScale, -sliderMargin, sliderHeight, 0),
        UDim2.new(1-sliderWidthScale, sliderMargin, sliderYOffsetStep * 0, 2), "Red",
        function(value) newPicker:SetValue(Color3.fromRGB(value, newPicker.Value.G * 255, newPicker.Value.B * 255)) end,
        0, 255, 1, true, newPicker.Value.R * 255, Color3.new(0.75,0,0)
    )
    newPicker:AddChild(newPicker.RSlider)

    newPicker.GSlider = SliderElement:New(
        UDim2.new(sliderWidthScale, -sliderMargin, sliderHeight, 0),
        UDim2.new(1-sliderWidthScale, sliderMargin, sliderYOffsetStep * 1, 4), "Green",
        function(value) newPicker:SetValue(Color3.fromRGB(newPicker.Value.R * 255, value, newPicker.Value.B * 255)) end,
        0, 255, 1, true, newPicker.Value.G * 255, Color3.new(0,0.75,0)
    )
    newPicker:AddChild(newPicker.GSlider)

    newPicker.BSlider = SliderElement:New(
        UDim2.new(sliderWidthScale, -sliderMargin, sliderHeight, 0),
        UDim2.new(1-sliderWidthScale, sliderMargin, sliderYOffsetStep * 2, 6), "Blue",
        function(value) newPicker:SetValue(Color3.fromRGB(newPicker.Value.R * 255, newPicker.Value.G * 255, value)) end,
        0, 255, 1, true, newPicker.Value.B * 255, Color3.new(0,0,0.75)
    )
    newPicker:AddChild(newPicker.BSlider)

    -- Hex Input Box
    newPicker.HexBox = TextBoxElement:New(
        UDim2.new(sliderWidthScale, -sliderMargin, sliderHeight, 0),
        UDim2.new(1-sliderWidthScale, sliderMargin, sliderYOffsetStep * 3, 8), "Hex",
        function(hexString)
            local r,g,b = hexString:match("^(%x%x)(%x%x)(%x%x)$")
            if r and g and b then
                newPicker:SetValue(Color3.fromRGB(tonumber("0x"..r), tonumber("0x"..g), tonumber("0x"..b)))
            end
        end, "^%x%x%x%x%x%x$", false, "" -- Not dynamic for hex, update on focus lost
    )
    newPicker:AddChild(newPicker.HexBox)
    
    -- Value (Brightness) Slider (from HSV)
    local _, _, initialV = Color3.toHSV(newPicker.Value)
    newPicker.VSlider = SliderElement:New(
        UDim2.new(sliderWidthScale, -sliderMargin, sliderHeight, 0),
        UDim2.new(1-sliderWidthScale, sliderMargin, sliderYOffsetStep * 5, -2), "Value", -- Different Y for last one
        function(vValue)
            local h, s, _ = Color3.toHSV(newPicker.Value)
            newPicker:SetValue(Color3.fromHSV(h, s, vValue / 255))
        end,
        0, 255, 1, true, initialV * 255, Color3.new(0.75,0.75,0.75)
    )
    newPicker:AddChild(newPicker.VSlider)
    
    local svImage = newPicker.SVImage :: ImageLabel
    svImage.ImageColor3 = Color3.fromHSV(0,1,1) -- Initial Hue for SV box (Red)

    local function updateSVFromInput(inputPos: Vector2Value)
        local localPos = svImage.AbsolutePosition
        local localSize = svImage.AbsoluteSize
        if localSize.X == 0 or localSize.Y == 0 then return end -- Avoid division by zero

        local saturation = math.clamp((inputPos.X - localPos.X) / localSize.X, 0, 1)
        local valueBrightness = math.clamp(1 - ((inputPos.Y - localPos.Y) / localSize.Y), 0, 1) -- Y is inverted for GUI

        local currentH, _, _ = Color3.toHSV(newPicker.Value) -- Keep current Hue
        newPicker:SetValue(Color3.fromHSV(currentH, saturation, valueBrightness))
    end

    svImage.InputBegan:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
            updateSVFromInput(inputObject.Position)
        end
    end)
    svImage.InputChanged:Connect(function(inputObject: InputObject) -- For dragging on SV image
         if inputObject.UserInputType == Enum.UserInputType.MouseMovement and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            if svImage.Parent and svImage.Parent:FindFirstChildOfClass("Frame") then -- Check if active
                local guiObject = svImage.Parent
                local mouseLocation = UserInputService:GetMouseLocation()
                -- Check if mouse is within the SVImage bounds (approx)
                if mouseLocation.X >= svImage.AbsolutePosition.X and mouseLocation.X <= svImage.AbsolutePosition.X + svImage.AbsoluteSize.X and
                   mouseLocation.Y >= svImage.AbsolutePosition.Y and mouseLocation.Y <= svImage.AbsolutePosition.Y + svImage.AbsoluteSize.Y then
                    updateSVFromInput(inputObject.Position)
                end
            end
        end
    end)
    
    newPicker:SetValue(newPicker.Value) -- Initialize all components
    return newPicker
end

function ColorPickerElement:SetValue(newColor: Color3Value)
    self.Value = newColor
    local hue, saturation, valueBrightness = Color3.toHSV(newColor)

    if (self :: any).SVImage then
        ((self :: any).SVImage :: ImageLabel).ImageColor3 = Color3.fromHSV(hue, 1, 1) -- Update hue of the SV box
        ((self :: any).SVCursor :: Frame).Position = UDim2.new(saturation, -2, 1 - valueBrightness, -2) -- Cursor position (Y inverted)
    end

    if (self :: any).VSlider then ((self :: any).VSlider :: any):SetValue(valueBrightness * 255) end
    if (self :: any).RSlider then ((self :: any).RSlider :: any):SetValue(newColor.R * 255) end
    if (self :: any).GSlider then ((self :: any).GSlider :: any):SetValue(newColor.G * 255) end
    if (self :: any).BSlider then ((self :: any).BSlider :: any):SetValue(newColor.B * 255) end
    if (self :: any).HexBox then
        ((self :: any).HexBox :: any):SetValue(string.format("%02x%02x%02x", newColor.R * 255, newColor.G * 255, newColor.B * 255))
    end

    pcall((self :: any).Callback, self.Value) -- Notify callback
end

function ColorPickerElement:UpdateGui()
    local mainFrame = self.GuiObject :: Frame
    mainFrame.Size = self.Size
    mainFrame.Position = self.Position
    mainFrame.BackgroundTransparency = 1 -- Main frame is container

    local svImage = (self :: any).SVImage :: ImageLabel
    svImage.Image = "rbxassetid://698052001" -- Saturation/Value gradient texture ID
    svImage.Size = UDim2.new(0.5, -10, 1, -10) -- Half width for SV, rest for sliders
    svImage.BorderSizePixel = 0
    svImage.Position = UDim2.new(0, 5, 0, 5)
    svImage.ScaleType = Enum.ScaleType.Stretch

    local svCursor = (self :: any).SVCursor :: Frame
    svCursor.Size = UDim2.new(0, 4, 0, 4)
    svCursor.BorderSizePixel = 1
    svCursor.BorderColor3 = Color3.new(1,1,1)
    svCursor.BackgroundColor3 = Color3.new(0,0,0) -- Or contrasting color
    svCursor.BackgroundTransparency = 0.5
    svCursor.ZIndex = svImage.ZIndex + 1

    -- Child sliders and textbox are updated by their own UpdateGui via RecursiveUpdateGui
    self:SetValue(self.Value) -- Refresh based on current value
end


-- ColorPicker Entry
local ColorPickerEntry: ColorPickerEntryType = setmetatable({}, BaseEntry)
ColorPickerEntry.__index = ColorPickerEntry

function ColorPickerEntry:New(
    title: string, callback: (newColor: Color3Value) -> (),
    isDynamic: boolean?, initialColor: Color3Value?
) : ColorPickerEntryType
    local newEntry:any = setmetatable(BaseEntry:New(), ColorPickerEntry) -- Start with default height
    newEntry.Title = title
    newEntry.Dynamic = isDynamic or false
    newEntry.Callback = callback
    newEntry.Value = initialColor or Theme.AccentColor -- Store value on entry too

    -- Label for the entry title
    newEntry.TitleLabel = Instance.new("TextLabel", newEntry.GuiObject)
    -- Small button to show current color and toggle picker
    newEntry.ColorDisplayButton = Instance.new("TextButton", newEntry.TitleLabel) -- Parent to label for positioning

    newEntry.PickerElement = ColorPickerElement:New(
        UDim2.new(1, 0, 0, Theme.HeaderWidth / 1.5), -- Picker height, adjust as needed
        UDim2.new(0, 0, 0, Theme.DefaultEntryHeight), -- Position below the title/button bar
        title,
        function(updatedColor) -- Picker's internal callback
            newEntry.ColorDisplayButton.BackgroundColor3 = updatedColor
            newEntry.Value = updatedColor
            if newEntry.Dynamic and newEntry.IsPickerVisible then
                pcall(newEntry.Callback, updatedColor)
            end
        end,
        isDynamic, initialColor
    )
    newEntry.PickerElement.GuiObject.Visible = false -- Initially hidden
    newEntry:AddChild(newEntry.PickerElement)

    newEntry.IsPickerVisible = false
    newEntry.Height = Theme.DefaultEntryHeight -- Initial height for the title bar only

    newEntry.ColorDisplayButton.MouseButton1Click:Connect(function()
        newEntry.IsPickerVisible = not newEntry.IsPickerVisible
        newEntry.PickerElement.GuiObject.Visible = newEntry.IsPickerVisible

        if newEntry.IsPickerVisible then
            newEntry.Height = Theme.DefaultEntryHeight + (Theme.HeaderWidth / 1.5) + Theme.EntryMargin -- Title bar + Picker + margin
        else
            newEntry.Height = Theme.DefaultEntryHeight
            pcall(newEntry.Callback, newEntry.Value) -- Callback with final color when closed
        end
        (newEntry.GuiObject :: Frame):TweenSize(
            UDim2.new(1,0,0,newEntry.Height),
            Enum.EasingDirection.InOut, Theme.AnimationEasingStyle, Theme.AnimationDuration, true
        )
        if newEntry.Parent and (newEntry.Parent :: CollapsibleContainerType).ReorderGui then
            (newEntry.Parent :: CollapsibleContainerType):ReorderGui()
        end
    end)
    newEntry:SetValue(newEntry.Value) -- Initialize color display
    return newEntry
end

function ColorPickerEntry:SetValue(newColor: Color3Value)
    self.Value = newColor
    if (self :: any).PickerElement then
        ((self :: any).PickerElement :: any):SetValue(newColor)
    end
    if (self :: any).ColorDisplayButton then
        ((self :: any).ColorDisplayButton :: TextButton).BackgroundColor3 = newColor
    end
end

function ColorPickerEntry:GetValue() : Color3Value
    return self.Value
end

function ColorPickerEntry:UpdateGui()
    -- Update BaseEntry parts
    BaseEntry.UpdateGui(self) -- Call superclass UpdateGui

    local guiFrame = self.GuiObject :: Frame
    guiFrame.ClipsDescendants = true -- Important for expanding/collapsing picker

    local titleLabel = (self :: any).TitleLabel :: TextLabel
    titleLabel.Size = UDim2.new(1, -16, 0, Theme.DefaultEntryHeight) -- Full width minus space for button, full default height
    titleLabel.Position = UDim2.new(0,0,0,0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Theme.Font
    titleLabel.Text = (self :: any).Title
    titleLabel.TextSize = Theme.TextSize
    titleLabel.TextColor3 = Theme.TextColor

    local colorButton = (self :: any).ColorDisplayButton :: TextButton
    colorButton.Size = UDim2.new(0, 16, 0, 16) -- Small square
    colorButton.Position = UDim2.new(1, -37, 0.5, -8) -- Right side of the label, centered vertically
    colorButton.Text = ""
    colorButton.AutoButtonColor = false
    colorButton.BorderSizePixel = 1
    colorButton.BorderColor3 = Theme.TextColor

    -- PickerElement is updated via RecursiveUpdateGui
    self:SetValue(self.Value) -- Ensure visual consistency
end

function CollapsibleContainer:CreateColorPicker(
    title: string, callback: (newColor: Color3Value) -> (),
    isDynamic: boolean?, initialColor: Color3Value?
) : ColorPickerEntryType
    local newEntry = ColorPickerEntry:New(title, callback, isDynamic, initialColor)
    self:AddEntry(newEntry)
    -- newEntry:RecursiveUpdateGui() -- AddEntry already calls this
    return newEntry
end


-- Utility function to filter a list of strings
local function filterListBySearchTerm(listToFilter: {string}, searchTerm: string) : {string}
    local results = {}
    if not searchTerm or searchTerm == "" then return listToFilter end -- Return all if no search term

    for _, itemText in pairs(listToFilter) do
        if string.match(string.lower(tostring(itemText)), string.lower(searchTerm)) then
            table.insert(results, itemText)
        end
    end
    return results
end

-- Selector List (Dropdown part of Selector)
local SelectorListElement = setmetatable({}, BaseUIElement) -- BaseUIElement provides Size, Position
SelectorListElement.__index = SelectorListElement

function SelectorListElement:New(
    size: UDim2Value, position: UDim2Value, titleForSearchBox: string,
    itemSelectionCallback: (selectedValue: string) -> (),
    getListFunc: GetListFunction
) : BaseUIElementType -- Specialized SelectorListElement
    local newList:any = setmetatable(BaseUIElement:New(size, position, titleForSearchBox), SelectorListElement)
    newList.ItemSelectionCallback = itemSelectionCallback
    newList.GetListFunction = getListFunc -- Function to get the current list of items

    newList.GuiObject = Instance.new("Frame") -- Main container for search and scroll
    local mainFrame = newList.GuiObject :: Frame

    newList.SearchBox = TextBoxElement:New(
        UDim2.new(1, 0, 0, 30), UDim2.new(0,0,0,0), -- Full width, 30px height
        "Search", -- Placeholder
        function(searchTerm) -- Callback for search box
            newList:PopulateList(filterListBySearchTerm(newList.GetListFunction(), searchTerm))
        end,
        nil, true -- No specific format, dynamic search
    )
    newList:AddChild(newList.SearchBox) -- Add as child for hierarchy, GuiObject parenting handled by AddChild

    newList.ScrollFrame = Instance.new("ScrollingFrame", mainFrame)
    return newList
end

function SelectorListElement:PopulateList(items: {string})
    local scrollFrame = (self :: any).ScrollFrame :: ScrollingFrame
    scrollFrame:ClearAllChildren() -- Clear previous items

    local currentYOffset = 0
    local itemHeight = 30
    for _, itemText in pairs(items) do
        local itemButton = Instance.new("TextButton", scrollFrame)
        itemButton.Text = tostring(itemText)
        itemButton.BackgroundColor3 = Theme.SecondaryColor
        itemButton.TextColor3 = Theme.TextColor
        itemButton.BorderColor3 = Theme.PrimaryColor -- Use Primary as border/divider
        itemButton.BorderSizePixel = 1
        itemButton.Size = UDim2.new(1, -4, 0, itemHeight) -- Full width minus padding, fixed height
        itemButton.Position = UDim2.new(0, 2, 0, currentYOffset)
        itemButton.Font = Theme.Font
        itemButton.TextSize = Theme.TextSize

        itemButton.MouseButton1Click:Connect(function()
            (self :: any).ItemSelectionCallback(itemText)
            -- Optionally, refresh list if GetListFunction's source can change
            -- self:PopulateList(filterListBySearchTerm(self.GetListFunction(), self.SearchBox:GetValue()))
        end)
        currentYOffset = currentYOffset + itemHeight
    end
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, #items * itemHeight)
end

function SelectorListElement:UpdateGui()
    local mainFrame = self.GuiObject :: Frame
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundTransparency = 1 -- Or Theme.PrimaryColor if visible frame desired
    mainFrame.Size = self.Size
    mainFrame.Position = self.Position

    -- SearchBox is updated via RecursiveUpdateGui

    local scrollFrame = (self :: any).ScrollFrame :: ScrollingFrame
    scrollFrame.Position = UDim2.new(0,0,0,30 + 2) -- Below search box, with margin
    scrollFrame.BackgroundTransparency = 1 -- Or Theme.PrimaryColor
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 6
    scrollFrame.ScrollBarImageColor3 = Theme.AccentColor
    scrollFrame.Size = UDim2.new(1,0,1,-32) -- Fill remaining space (Total height - searchbox height - margin)
    
    self:PopulateList((self :: any).GetListFunction()) -- Initial population
end


-- Selector Entry (Dropdown/ComboBox)
local SelectorEntry: SelectorEntryType = setmetatable({}, BaseEntry)
SelectorEntry.__index = SelectorEntry

function SelectorEntry:New(
    title: string, callback: (selectedValue: string) -> (),
    getListFunc: GetListFunction, initialValue: string?
) : SelectorEntryType
    local newEntry:any = setmetatable(BaseEntry:New(), SelectorEntry) -- Default height initially
    newEntry.Title = title
    newEntry.Callback = callback
    newEntry.Value = initialValue -- Store the selected value

    -- Button to display current value and toggle dropdown
    newEntry.DisplayButton = Instance.new("TextButton", newEntry.GuiObject)
    newEntry.DropdownIndicator = Instance.new("TextLabel", newEntry.DisplayButton) -- Arrow indicator

    -- The actual dropdown list part
    newEntry.SelectorList = SelectorListElement:New(
        UDim2.new(1, 0, 0, Theme.DefaultEntryHeight * 5), -- Size of the dropdown when open
        UDim2.new(0, 0, 0, Theme.DefaultEntryHeight),   -- Position below the display button
        title, -- Title for search box within selector list
        function(selectedValue) -- Callback when an item is selected from the list
            if not UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then -- Allow multi-select with Shift?
                newEntry:ToggleDropdown() -- Close dropdown on selection if shift is not held
            end
            newEntry:SetValue(selectedValue) -- Update display button text
            pcall(newEntry.Callback, selectedValue) -- Call main callback
        end,
        getListFunc
    )
    newEntry.SelectorList.GuiObject.Visible = false -- Hidden initially
    newEntry:AddChild(newEntry.SelectorList)

    newEntry.IsDropdownVisible = false
    newEntry.Height = Theme.DefaultEntryHeight -- Initial height for display button

    newEntry.DisplayButton.MouseButton1Click:Connect(function()
        newEntry:ToggleDropdown()
        if newEntry.IsDropdownVisible then -- If just opened, refresh list
            newEntry.SelectorList:PopulateList(
                filterListBySearchTerm(newEntry.SelectorList.GetListFunction(), newEntry.SelectorList.SearchBox:GetValue() or "")
            )
        end
    end)

    newEntry:SetValue(initialValue) -- Set initial display text
    return newEntry
end

function SelectorEntry:ToggleDropdown()
    local self = self :: SelectorEntryType & { _private: {IsDropdownVisible: boolean, SelectorList: { GuiObject: GuiObject }, DropdownIndicator: TextLabel, Parent: CollapsibleContainerType} }
    self.IsDropdownVisible = not self.IsDropdownVisible
    self.SelectorList.GuiObject.Visible = self.IsDropdownVisible

    if self.IsDropdownVisible then
        self.Height = Theme.DefaultEntryHeight + (Theme.DefaultEntryHeight*5) + Theme.EntryMargin -- Button height + Dropdown height + margin
        self.DropdownIndicator.Text = "▲" -- Up arrow
    else
        self.Height = Theme.DefaultEntryHeight
        self.DropdownIndicator.Text = "▼" -- Down arrow
    end

    (self.GuiObject :: Frame):TweenSize(
        UDim2.new(1,0,0,self.Height),
        Enum.EasingDirection.InOut, Theme.AnimationEasingStyle, Theme.AnimationDuration, true
    )
    if self.Parent and self.Parent.ReorderGui then
        self.Parent:ReorderGui()
    end
end

function SelectorEntry:SetValue(newValue: string?)
    self.Value = newValue
    local displayButton = (self :: any).DisplayButton :: TextButton
    displayButton.Text = string.format("%s: %s", (self :: any).Title, tostring(newValue or "Empty"))
end

function SelectorEntry:GetValue() : string?
    return self.Value
end

function SelectorEntry:UpdateGui()
    BaseEntry.UpdateGui(self) -- Call superclass UpdateGui

    local guiFrame = self.GuiObject :: Frame
    guiFrame.ClipsDescendants = true -- Important for dropdown

    local displayButton = (self :: any).DisplayButton :: TextButton
    displayButton.Position = UDim2.new(0,5,0,5) -- Margin
    displayButton.Size = UDim2.new(1,-10,0, Theme.DefaultEntryHeight - 10) -- Fill entry height with margin
    displayButton.BorderSizePixel = 0
    displayButton.Font = Theme.Font
    displayButton.TextSize = Theme.TextSize
    displayButton.BackgroundColor3 = Theme.SecondaryColor
    displayButton.TextColor3 = Theme.TextColor
    displayButton.AutoButtonColor = false
    displayButton.TextXAlignment = Enum.TextXAlignment.Left
    displayButton.TextTruncate = Enum.TextTruncate.AtEnd

    local indicator = (self :: any).DropdownIndicator :: TextLabel
    indicator.Size = UDim2.new(0,20,0,20)
    indicator.Position = UDim2.new(1, -25, 0.5, -10) -- Right end of the button
    indicator.BackgroundTransparency = 1
    indicator.TextColor3 = Theme.TextColor
    indicator.Font = Theme.Font
    indicator.TextSize = Theme.TextSize
    indicator.Text = if (self :: any).IsDropdownVisible then "▲" else "▼" end

    -- SelectorList is updated via RecursiveUpdateGui
    self:SetValue(self.Value) -- Refresh display text
end

function CollapsibleContainer:CreateSelector(
    title: string, callback: (selectedValue: string) -> (),
    getListFunc: GetListFunction, initialValue: string?
) : SelectorEntryType
    local newEntry = SelectorEntry:New(title, callback, getListFunc, initialValue)
    self:AddEntry(newEntry)
    return newEntry
end

-- Switch (Toggle) Element
local SwitchElement = setmetatable({}, BaseUIElement)
SwitchElement.__index = SwitchElement

function SwitchElement:New(
    size: UDim2Value, position: UDim2Value, title: string,
    callback: (isOn: boolean) -> (), initialValue: boolean?
) : BaseUIElementType -- Specialized SwitchElement
    local newSwitch:any = setmetatable(BaseUIElement:New(size, position, title), SwitchElement)
    newSwitch.Callback = callback
    newSwitch.Value = initialValue or false -- Default to off

    newSwitch.GuiObject = Instance.new("Frame") -- Main container for label and button
    local mainFrame = newSwitch.GuiObject :: Frame

    newSwitch.TitleLabel = Instance.new("TextLabel", mainFrame)
    newSwitch.ToggleButton = Instance.new("TextButton", mainFrame) -- The clickable switch part

    newSwitch.ToggleButton.MouseButton1Click:Connect(function()
        newSwitch:SetValue(not newSwitch.Value) -- Toggle
        pcall(newSwitch.Callback, newSwitch.Value)
    end)
    return newSwitch
end

function SwitchElement:SetValue(isOn: boolean)
    self.Value = isOn
    local toggleButton = (self :: any).ToggleButton :: TextButton
    if self.Value then
        toggleButton.BackgroundColor3 = Theme.AccentColor
        toggleButton.Text = "" -- Or "ON"
    else
        toggleButton.BackgroundColor3 = Theme.SecondaryColor -- Darker shade for "off"
        toggleButton.Text = "" -- Or "OFF"
    end
end

function SwitchElement:UpdateGui()
    local mainFrame = self.GuiObject :: Frame
    mainFrame.Size = self.Size
    mainFrame.BackgroundTransparency = 1
    mainFrame.Position = self.Position

    local titleLabel = (self :: any).TitleLabel :: TextLabel
    titleLabel.Text = self.Title
    titleLabel.TextSize = Theme.TextSize
    titleLabel.Font = Theme.Font
    titleLabel.BackgroundTransparency = 1
    titleLabel.Size = UDim2.new(0.8, -5, 1, 0) -- 80% width for label, leave space for button
    titleLabel.Position = UDim2.new(0,0,0,0)
    titleLabel.TextColor3 = Theme.TextColor
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left

    local toggleButton = (self :: any).ToggleButton :: TextButton
    toggleButton.Size = UDim2.new(0, 20, 0, 20) -- Square button
    toggleButton.BorderSizePixel = 1
    toggleButton.BorderColor3 = Theme.TextColor:Lerp(Theme.SecondaryColor, 0.3)
    toggleButton.Position = UDim2.new(1, -20-5, 0.5, -10) -- Position at the right end, centered vertically
    toggleButton.TextColor3 = Theme.TextColor -- For "ON"/"OFF" text if used
    toggleButton.TextSize = Theme.TextSize * 0.8
    toggleButton.Font = Theme.Font

    self:SetValue(self.Value) -- Apply current state
end

-- Switch Entry
local SwitchEntry: SwitchEntryType = setmetatable({}, BaseEntry)
SwitchEntry.__index = SwitchEntry

function SwitchEntry:New(
    title: string, callback: (isOn: boolean) -> (), initialValue: boolean?
) : SwitchEntryType
    local newEntry = setmetatable(BaseEntry:New(), SwitchEntry)
    newEntry.Switch = SwitchElement:New(
        UDim2.new(1, -10, 1, -10), UDim2.new(0,5,0,5), -- Relative to entry
        title, callback, initialValue
    )
    newEntry:AddChild(newEntry.Switch)
    return newEntry
end

function SwitchEntry:SetValue(isOn: boolean)
    self.Value = isOn
    (self.Switch :: any):SetValue(isOn)
end

function SwitchEntry:GetValue() : boolean
    return (self.Switch :: any):GetValue()
end

function CollapsibleContainer:CreateSwitch(
    title: string, callback: (isOn: boolean) -> (), initialValue: boolean?
) : SwitchEntryType
    local newEntry = SwitchEntry:New(title, callback, initialValue)
    self:AddEntry(newEntry)
    return newEntry
end

-- Simple TextLabel Element (not an entry, but a raw element)
local TextLabelElement = setmetatable({}, BaseUIElement)
TextLabelElement.__index = TextLabelElement

function TextLabelElement:New(size: UDim2Value, position: UDim2Value, text: string) : BaseUIElementType
    local newLabel = setmetatable(BaseUIElement:New(size, position, text), TextLabelElement) -- Title is the text
    newLabel.GuiObject = Instance.new("TextLabel")
    return newLabel
end

function TextLabelElement:UpdateGui()
    local guiLabel = self.GuiObject :: TextLabel
    guiLabel.BorderSizePixel = 0
    guiLabel.BackgroundTransparency = 1
    guiLabel.TextColor3 = Theme.TextColor
    guiLabel.Size = self.Size
    guiLabel.Position = self.Position
    guiLabel.Text = self.Title -- Text comes from the title
    guiLabel.TextSize = Theme.TextSize
    guiLabel.Font = Theme.Font
    guiLabel.TextWrapped = true
    guiLabel.TextXAlignment = Enum.TextXAlignment.Left
    guiLabel.TextYAlignment = Enum.TextYAlignment.Center
end

function CollapsibleContainer:CreateTextLabel(text: string) : BaseEntryType
    local entryWrapper = BaseEntry:New() -- Default height, or calculate based on text?
    -- For multiline, might need dynamic height for entryWrapper
    -- entryWrapper.Height = ?
    local labelElement = TextLabelElement:New(
        UDim2.new(1, -10, 1, -10), UDim2.new(0,5,0,5),
        text
    )
    entryWrapper:AddChild(labelElement)
    self:AddEntry(entryWrapper)
    return entryWrapper
end

-- KeyDetector Element (for keybinds)
local KeyInputElement = setmetatable({}, BaseUIElement)
KeyInputElement.__index = KeyInputElement

function KeyInputElement:New(
    size: UDim2Value, position: UDim2Value, title: string,
    callback: (newKey: KeyCodeEnum) -> (), initialValue: KeyCodeEnum?
) : BaseUIElementType -- Specialized KeyInputElement
    local newKeyInput:any = setmetatable(BaseUIElement:New(size, position, title), KeyInputElement)
    newKeyInput.Callback = callback
    newKeyInput.Value = initialValue or Enum.KeyCode.Unknown

    newKeyInput.GuiObject = Instance.new("Frame") -- Container for label and button
    local mainFrame = newKeyInput.GuiObject :: Frame

    newKeyInput.TitleLabel = Instance.new("TextLabel", mainFrame)
    newKeyInput.InputButton = Instance.new("TextButton", mainFrame) -- Button to click for key detection

    newKeyInput.InputButton.MouseButton1Click:Connect(function()
        newKeyInput.InputButton.Text = "..." -- Indicate listening
        local inputConnection: RBXScriptConnection
        inputConnection = UserInputService.InputBegan:Connect(function(inputObject: InputObject, gameProcessedEvent: boolean)
            if not gameProcessedEvent and inputObject.UserInputType == Enum.UserInputType.Keyboard then
                newKeyInput:SetValue(inputObject.KeyCode)
                pcall(newKeyInput.Callback, newKeyInput.Value)
                if inputConnection then
                    inputConnection:Disconnect() -- Stop listening after one key
                end
            elseif inputObject.UserInputType == Enum.UserInputType.MouseButton1 then -- Allow click off
                 newKeyInput.InputButton.Text = (newKeyInput.Value :: KeyCodeEnum).Name -- Revert text
                 if inputConnection then inputConnection:Disconnect() end
            end
        end)
    end)
    return newKeyInput
end

function KeyInputElement:SetValue(newKey: KeyCodeEnum)
    self.Value = newKey
    if (self :: any).InputButton then
        ((self :: any).InputButton :: TextButton).Text = newKey.Name
    end
end

function KeyInputElement:UpdateGui()
    local mainFrame = self.GuiObject :: Frame
    mainFrame.BackgroundTransparency = 1
    mainFrame.Size = self.Size
    mainFrame.Position = self.Position

    local titleLabel = (self :: any).TitleLabel :: TextLabel
    titleLabel.Size = UDim2.new(0.7, -5, 1, 0) -- 70% for label
    titleLabel.BackgroundTransparency = 1
    titleLabel.TextSize = Theme.TextSize
    titleLabel.Text = self.Title
    titleLabel.Font = Theme.Font
    titleLabel.TextColor3 = Theme.TextColor
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left

    local inputButton = (self :: any).InputButton :: TextButton
    inputButton.Size = UDim2.new(0.3, 0, 1, 0) -- 30% for button
    inputButton.Position = UDim2.new(0.7, 5, 0, 0)
    inputButton.BorderSizePixel = 0
    inputButton.TextColor3 = Theme.TextColor
    inputButton.BackgroundColor3 = Theme.SecondaryColor
    inputButton.Font = Theme.Font
    inputButton.TextSize = Theme.TextSize * 0.9
    
    self:SetValue(self.Value :: KeyCodeEnum)
end

-- KeyDetector Entry
local KeyInputEntry: KeyInputEntryType = setmetatable({}, BaseEntry)
KeyInputEntry.__index = KeyInputEntry

function KeyInputEntry:New(
    title: string, callback: (newKey: KeyCodeEnum) -> (), initialValue: KeyCodeEnum?
) : KeyInputEntryType
    local newEntry = setmetatable(BaseEntry:New(), KeyInputEntry)
    newEntry.KeyDetector = KeyInputElement:New(
        UDim2.new(1, -10, 1, -10), UDim2.new(0,5,0,5),
        title, callback, initialValue
    )
    newEntry:AddChild(newEntry.KeyDetector)
    return newEntry
end

function KeyInputEntry:SetValue(newKey: KeyCodeEnum)
    self.Value = newKey
    (self.KeyDetector :: any):SetValue(newKey)
end

function KeyInputEntry:GetValue() : KeyCodeEnum
    return (self.KeyDetector :: any):GetValue()
end

function CollapsibleContainer:CreateKeyDetector(
    title: string, callback: (newKey: KeyCodeEnum) -> (), initialValue: KeyCodeEnum?
) : KeyInputEntryType
    local newEntry = KeyInputEntry:New(title, callback, initialValue)
    self:AddEntry(newEntry)
    return newEntry
end

-- Root UI Manager / Controller
local UIManager: RootUIType = setmetatable({}, BaseUINode) -- Root is a BaseUINode
UIManager.__index = UIManager

function UIManager:New(parentGuiInstance: GuiObject?) : RootUIType
    local newRoot:any = setmetatable(BaseUINode:New(ElementType.Root), UIManager)

    if parentGuiInstance and parentGuiInstance:IsA("ScreenGui") then
        newRoot.ScreenGui = parentGuiInstance
    else
        newRoot.ScreenGui = Instance.new("ScreenGui", parentGuiInstance or Players.LocalPlayer:FindFirstChildOfClass("PlayerGui") or game:GetService("CoreGui"))
    end
    
    -- Main Frame for the UIManager, child of ScreenGui. All categories will be parented to this.
    newRoot.GuiObject = Instance.new("Frame", newRoot.ScreenGui)
    return newRoot
end

function UIManager:UpdateGui() -- Overrides BaseUINode UpdateGui
    self.ScreenGui.ResetOnSpawn = false
    self.ScreenGui.IgnoreGuiInset = true -- Cover entire screen if needed, or can be configurable
    self.ScreenGui.Enabled = true -- Ensure it's visible by default

    local mainFrame = self.GuiObject :: Frame
    mainFrame.Size = UDim2.new(1,0,1,0) -- Full screen
    mainFrame.BackgroundTransparency = 1 -- Transparent, categories provide their own background
end

function UIManager:Hide()
    self.ScreenGui.Enabled = false
end

function UIManager:Show()
    self.ScreenGui.Enabled = true
end

function UIManager:CleanUp()
    self.ScreenGui:Destroy()
    -- Disconnect any global connections if made by the UIManager itself
    -- Set self to nil effectively (done by caller or garbage collection)
end

function UIManager:CreateCategory(title: string, positionOrDraggable: UDim2Value | boolean?) : CategoryType
    local categoryDraggable = true
    local categoryPosition: UDim2Value | nil = nil

    if typeof(positionOrDraggable) == "UDim2" then
        categoryPosition = positionOrDraggable
    elseif typeof(positionOrDraggable) == "boolean" then
        categoryDraggable = positionOrDraggable
    end
    
    local newCategory = Category:New(title, categoryDraggable)
    self:AddChild(newCategory) -- Add category to UIManager's children

    if categoryPosition then
        newCategory:MoveTo(categoryPosition)
    else
        newCategory:AutoMove() -- Auto-position if no specific position given
    end

    newCategory:RecursiveUpdateGui() -- Update the new category and its children (header)
    return newCategory
end

function UIManager:LoadConfig(config: table)
    for key, value in pairs(config) do
        if Theme[key] then
            Theme[key] = value
        else
            warn("[UIManager] Unknown theme option in LoadConfig:", key)
        end
    end
    -- After loading config, might want to update all existing UI if any
    -- self:RecursiveUpdateGui() -- If UI elements are already created
end

-- Static initialization method for the UIManager
function UIManager.Init(config: table?, parentGuiInstance: GuiObject?) : RootUIType
    local uiManagerInstance = UIManager:New(parentGuiInstance)
    if config then
        uiManagerInstance:LoadConfig(config)
    end
    uiManagerInstance:RecursiveUpdateGui() -- Initial full UI update
    return uiManagerInstance
end

return UIManager
